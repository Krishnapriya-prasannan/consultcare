//login patient 

DELIMITER //

CREATE PROCEDURE LoginUser(
    IN input_phone_no VARCHAR(15),
    IN input_dob DATE,
    OUT output_patient_id INT,
    OUT output_message VARCHAR(255)
)
BEGIN
    DECLARE user_exists INT;
    DECLARE patient_status VARCHAR(10);

    -- Check if the user exists with the provided phone number and date of birth
    SELECT COUNT(*) INTO user_exists
    FROM Patient
    WHERE pat_ph_no = input_phone_no AND pat_dob = input_dob;

    -- If user exists, retrieve the patient ID and status
    IF user_exists = 1 THEN
        SELECT pat_id, pat_status INTO output_patient_id, patient_status
        FROM Patient
        WHERE pat_ph_no = input_phone_no AND pat_dob = input_dob;

        -- Check the patient's status
        IF patient_status = 'A' THEN
            SET output_message = 'Login successful';
        ELSEIF patient_status = 'L' THEN
            SET output_message = 'Your account has been deleted. Please contact support if this is an error.';
            SET output_patient_id = NULL; -- Set to NULL since login fails
        END IF;
    ELSE
        -- If no matching user is found
        SET output_message = 'Invalid phone number or date of birth';
        SET output_patient_id = NULL; -- Set to NULL since login fails
    END IF;
END //

DELIMITER ;

// signup and edit patient 

DELIMITER //

CREATE PROCEDURE ManagePatientProfile(
    IN flag VARCHAR(3),                -- 'INS' for insert, 'UPD' for update, 'DEL' for delete
    IN in_pat_id INT,                  -- Patient ID (for update or delete)
    IN in_pat_name VARCHAR(60),        -- Patient Name (for insert or update)
    IN in_pat_dob DATE,                -- Patient Date of Birth (for insert or update)
    IN in_pat_adr VARCHAR(100),        -- Patient Address (for insert or update)
    IN in_pat_ph_no VARCHAR(15),       -- Patient Phone Number (for insert or update)
    IN in_pat_email VARCHAR(60),       -- Patient Email (for insert or update)
    IN in_pat_sex VARCHAR(1),          -- Patient Sex (for insert or update)
    IN in_pat_reg_no VARCHAR(10)     -- Patient Registration Number (for insert or update)
)
BEGIN
    DECLARE existing_phone INT;

    -- If flag is 'INS', check if the phone number already exists
    IF flag = 'INS' THEN
        SELECT COUNT(*) INTO existing_phone 
        FROM Patient 
        WHERE pat_ph_no = in_pat_ph_no;

        IF existing_phone > 0 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Phone number already exists.';
        ELSE
            INSERT INTO Patient (pat_name, pat_dob, pat_adr, pat_ph_no, pat_email, pat_sex, pat_reg_no, pat_status)
            VALUES (in_pat_name, in_pat_dob, in_pat_adr, in_pat_ph_no, in_pat_email, in_pat_sex, CONCAT('R', AutoGenerate('REG')),'A');
        END IF;

    -- If flag is 'UPD', check if the patient ID exists
    ELSEIF flag = 'UPD' THEN
        SELECT COUNT(*) INTO existing_phone 
        FROM Patient 
        WHERE pat_id = in_pat_id;

        IF existing_phone = 0 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Patient ID does not exist.';
        ELSE
            UPDATE Patient
            SET 
                pat_name = in_pat_name,
                pat_dob = in_pat_dob,
                pat_adr = in_pat_adr,
                pat_ph_no = in_pat_ph_no,
                pat_email = in_pat_email,
                pat_sex = in_pat_sex,
                pat_reg_no = in_pat_reg_no,
                pat_status = 'A'
            WHERE pat_id = in_pat_id;
        END IF;

    -- If flag is 'DEL', mark the patient as deleted
    ELSEIF flag = 'DEL' THEN
        SELECT COUNT(*) INTO existing_phone 
        FROM Patient 
        WHERE pat_id = in_pat_id;

        IF existing_phone = 0 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Patient ID does not exist.';
        ELSE
            UPDATE Patient
            SET 
                pat_status = 'L'  -- 'L' for locked or deleted status
            WHERE pat_id = in_pat_id;
        END IF;
    END IF;
END //

DELIMITER ;


//retrive patient details

DELIMITER //

CREATE PROCEDURE Retrieve_Pat_Details(
    IN input_pat_id INT,
    OUT patient_name VARCHAR(60),
    OUT patient_dob DATE,
    OUT patient_adr VARCHAR(100),
    OUT patient_ph_no VARCHAR(15),
    OUT patient_email VARCHAR(60),
    OUT patient_reg_no VARCHAR(10),  -- Changed to match the table definition
    OUT patient_sex VARCHAR(1),
    OUT patient_status VARCHAR(1)
)
BEGIN
    -- Initialize output variables
    SET patient_name = NULL;
    SET patient_dob = NULL;
    SET patient_adr = NULL;
    SET patient_ph_no = NULL;
    SET patient_email = NULL;
    SET patient_reg_no = NULL;  -- Changed to match the table definition
    SET patient_sex = NULL;
    SET patient_status = NULL;

    -- Query to retrieve patient details based on patient ID
    SELECT 
        p.pat_name, 
        p.pat_dob, 
        p.pat_adr, 
        p.pat_ph_no, 
        p.pat_email, 
        p.pat_reg_no, 
        p.pat_sex,
        p.pat_status
    INTO 
        patient_name, 
        patient_dob, 
        patient_adr, 
        patient_ph_no, 
        patient_email, 
        patient_reg_no,  -- Changed to match the table definition
        patient_sex,
        patient_status
    FROM 
        Patient AS p
    WHERE 
        p.pat_id = input_pat_id; -- Changed to match the column name in the Patient table

    -- Check if patient exists
    IF patient_name IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Patient not found';
    END IF;
END //

DELIMITER ;

//staff login

DELIMITER //

CREATE PROCEDURE LoginStaff(IN staffUsername VARCHAR(255))
BEGIN
    DECLARE staff_pswd VARCHAR(255);
    DECLARE staff_status CHAR(1);   -- Status will be 'A' or 'L'
    DECLARE staff_type CHAR(1);     -- Staff type will be 'A' (Admin) or 'D' (Doctor)
    DECLARE msg VARCHAR(255);

    -- Fetch the staff password, status, and type
    SELECT stf_pswd, stf_status, stf_type INTO staff_pswd, staff_status, staff_type
    FROM Staff
    WHERE stf_username = staffUsername;

    -- Check if the staff exists and status is active
    IF staff_pswd IS NULL THEN
        SET msg = 'Invalid credentials.';
    ELSEIF staff_status = 'L' THEN
        SET msg = 'Account is locked.';
    ELSEIF staff_status = 'A' THEN
        SET msg = 'Login successful.';
    END IF;

    -- Set output parameters
    SET @staff_type = staff_type;
    SET @message = msg;
END //

DELIMITER ;

DELIMITER //
CREATE PROCEDURE GetDoctorDetails(IN doctorId INT)
BEGIN
    SELECT stf_id, stf_name,stf_username, stf_speciality, stf_email, stf_ph_no, 
           stf_qualification, stf_experience, stf_sex, stf_img_path,stf_pswd
    FROM Staff
    WHERE stf_id = doctorId;
END //
DELIMITER ;


DELIMITER //
CREATE PROCEDURE UpdateDoctorPassword(IN doctorId INT, IN newPassword VARCHAR(100))
BEGIN
    UPDATE Staff
    SET stf_pswd = newPassword
    WHERE stf_id = doctorId;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE GetAdminDetails(IN adminId INT)
BEGIN
    SELECT stf_id, stf_name,stf_username, stf_speciality, stf_email, stf_ph_no, 
           stf_qualification, stf_experience, stf_sex, stf_img_path,stf_pswd
    FROM Staff
    WHERE stf_id = adminId;
END //
DELIMITER ;


DELIMITER //

CREATE PROCEDURE updateAdminDetails(
    IN adminId INT,
    IN adminName VARCHAR(60),
    IN adminUsername VARCHAR(50),
    IN adminSex VARCHAR(1),
    IN adminEmail VARCHAR(60),
    IN adminPhoneNo VARCHAR(15),
    IN adminSpeciality VARCHAR(50),
    IN adminPassword VARCHAR(100),
    IN adminExperience VARCHAR(500),
    IN adminQualification VARCHAR(100)
)
BEGIN
    UPDATE Staff
    SET stf_name = adminName,
        stf_username = adminUsername,
        stf_sex = adminSex,
        stf_email = adminEmail,
        stf_ph_no = adminPhoneNo,
        stf_speciality = adminSpeciality,
        stf_pswd = adminPassword,
        stf_experience = adminExperience,
        stf_qualification = adminQualification
    WHERE stf_id = adminId;
END //

DELIMITER ;

DELIMITER //

CREATE PROCEDURE GetPatientsByDoctor(IN staff_id INT)
BEGIN
    SELECT p.pat_reg_no AS regNo,
           p.pat_name AS name,
           TIMESTAMPDIFF(YEAR, p.pat_dob, CURDATE()) AS age,
           p.pat_sex AS sex,
           p.pat_ph_no AS phoneNumber
    FROM Patient p
    JOIN Appointment a ON p.pat_id = a.appt_pat_id
    WHERE a.appt_stf_id = staff_id 
    AND p.pat_status = 'A'
    GROUP BY p.pat_id;
END //

DELIMITER ;


DELIMITER //

CREATE PROCEDURE GetTodayAppointments(IN staffId INT)
BEGIN
    SELECT 
    
        a.appt_tok_no AS tokenNo,
        p.pat_reg_no AS regNo,
        p.pat_name AS name,
        YEAR(CURDATE()) - YEAR(p.pat_dob) AS age,
        p.pat_sex AS sex
    FROM 
        Appointment a
    JOIN 
        Patient p ON a.appt_pat_id = p.pat_id
    WHERE 
        a.appt_stf_id = staffId 
        AND a.appt_date = CURDATE() 
        AND a.appt_status = 'B'
        AND p.pat_status = 'A'
    ORDER BY 
        a.appt_tok_no;
END //

DELIMITER ;

DELIMITER //
CREATE PROCEDURE CreateLeave(
    IN p_stf_id INT,
    IN p_hol_date DATE,
    IN p_hol_type VARCHAR(3),
    IN p_hol_reason VARCHAR(200)
)
BEGIN
    INSERT INTO Holiday (hol_stf_id, hol_date, hol_type, hol_reason, hol_status) 
    VALUES (p_stf_id, p_hol_date, p_hol_type, p_hol_reason, 'W');
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE GetLeaveHistory(
    IN p_stf_id INT
)
BEGIN
    SELECT * FROM Holiday WHERE hol_stf_id = p_stf_id;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE UpdateLeave(
    IN p_hol_id INT,
    IN p_hol_type VARCHAR(3),
    IN p_hol_date DATE,
    IN p_hol_reason VARCHAR(200)
)
BEGIN
    UPDATE Holiday
    SET hol_type = p_hol_type, hol_date = p_hol_date, hol_reason = p_hol_reason, hol_status = 'W'
    WHERE hol_id = p_hol_id;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE DeleteLeave(
    IN p_hol_id INT
)
BEGIN
    DELETE FROM Holiday WHERE hol_id = p_hol_id;
END //
DELIMITER ;
 

 DELIMITER //
CREATE PROCEDURE GetAllLeaves()
BEGIN
    SELECT h.hol_id, h.hol_date, h.hol_type, h.hol_reason, h.hol_status, s.stf_name
    FROM Holiday h
    JOIN Staff s ON h.hol_stf_id = s.stf_id;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE ApproveRejectLeave(
    IN p_hol_id INT,
    IN p_status VARCHAR(10)
)
BEGIN
    UPDATE Holiday
    SET hol_status = p_status
    WHERE hol_id = p_hol_id;
END //
DELIMITER ;

DELIMITER //

CREATE PROCEDURE GetLeavesByStatus(IN leaveStatus VARCHAR(20))
BEGIN
  SELECT h.hol_id, h.hol_date, h.hol_type, h.hol_reason, h.hol_status, s.stf_name
    FROM Holiday h
    JOIN Staff s ON h.hol_stf_id = s.stf_id WHERE h.hol_status = leaveStatus;
END //

DELIMITER ;



DELIMITER //

CREATE PROCEDURE AddNewChart(
    IN patientRegNo VARCHAR(10),
    IN doctorId INT,
    IN appointmentDate DATE,
    IN patientCondition TEXT,
    IN diagnosis TEXT,
    IN remarks TEXT,
    IN medName VARCHAR(100),
    IN medDosage VARCHAR(50),
    IN medDuration VARCHAR(30),
    IN medInstruction TINYTEXT,
    IN medRemarks TINYTEXT
)
BEGIN
    DECLARE new_cons_id INT;
    DECLARE patientId INT;
    DECLARE apptId INT;

    -- Get patient ID from the Patient table based on the patient registration number
    SELECT pat_id INTO patientId 
    FROM Patient 
    WHERE pat_reg_no = patientRegNo;

    -- Check if the appointment exists
    SELECT appt_id INTO apptId
    FROM Appointment 
    WHERE appt_date = appointmentDate 
      AND appt_pat_id = patientId 
      AND appt_stf_id = doctorId

    LIMIT 1;

    -- Debug: Check if appointment exists
    IF apptId IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Appointment does not exist';
    END IF;

    -- Check if a consultation already exists for this appointment
    SELECT cons_id INTO new_cons_id
    FROM Consultation
    WHERE cons_appt_id = apptId
    LIMIT 1;

    -- If no consultation exists, insert a new one
    IF new_cons_id IS NULL THEN
        INSERT INTO Consultation (cons_appt_id, cons_stf_id, cons_pat_id, cons_pat_condition, cons_diagnosis, cons_remarks)
        VALUES (apptId, doctorId, patientId, patientCondition, diagnosis, remarks);
        
        -- Get the last inserted consultation ID
        SET new_cons_id = LAST_INSERT_ID();
    END IF;

    -- Insert into Medication table, associating with the existing or newly created consultation
    INSERT INTO Medication (med_cons_id, med_appt_id, med_name, med_dosage, med_duration, med_instruction, med_remarks)
    VALUES (new_cons_id, apptId, medName, medDosage, medDuration, medInstruction, medRemarks);
END //

DELIMITER ;



DELIMITER //

CREATE TRIGGER after_consultation_insert
AFTER INSERT ON Consultation
FOR EACH ROW
BEGIN
    -- Update the appointment status from 'B' to 'F' for the corresponding appointment
    UPDATE Appointment
    SET appt_status = 'F'
    WHERE appt_id = NEW.cons_appt_id AND appt_status = 'B';
END;

//

DELIMITER ;




require('dotenv').config();
const express = require('express');
const mysql = require('mysql2');
const cors = require('cors');
const bodyParser = require('body-parser');
const bcrypt = require('bcrypt');

const app = express();
const port = 5000;

app.use(cors());
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

// Database configuration
const dbConfig = {
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_DATABASE,
};
if (process.env.DB_SOCKET_PATH) {
  dbConfig.socketPath = process.env.DB_SOCKET_PATH;
}
// Create the database connection pool
const db = mysql.createPool(dbConfig);

// Connection testing
db.getConnection((err) => {
  if (err) {
    console.error('Error connecting to MySQL:', err);
    return;
  }
  console.log('Connected to MySQL database');
});




// POST /api/patients/signup
app.post('/api/patients/signup', (req, res) => {
  const { pat_name, pat_dob, pat_adr, pat_ph_no, pat_email, pat_sex } = req.body;

  const query = `CALL ManagePatientProfile(?, NULL, ?, ?, ?, ?, ?, ?, NULL)`;

  db.query(query, ['INS', pat_name, pat_dob, pat_adr, pat_ph_no, pat_email, pat_sex], (err, results) => {
      if (err) {
          if (err.sqlState === '45000') {
              return res.status(400).json({ error: err.message });  // Custom error from the procedure
          }
          return res.status(500).json({ error: 'Database error.' });
      }
      return res.status(201).json({ message: 'Patient signed up successfully.', data: results });
  });
});

// PUT /api/patients/update/:id
app.put('/api/patients/update/:id', (req, res) => {
  const pat_id = req.params.id;
  const { pat_name, pat_dob, pat_adr, pat_ph_no, pat_email, pat_sex, pat_reg_no } = req.body;

  const query = `CALL ManagePatientProfile(?, ?, ?, ?, ?, ?, ?, ?, ?)`;

  db.query(query, ['UPD', pat_id, pat_name, pat_dob, pat_adr, pat_ph_no, pat_email, pat_sex, pat_reg_no], (err, results) => {
      if (err) {
          if (err.sqlState === '45000') {
              return res.status(400).json({ error: err.message });  // Custom error from the procedure
          }
          return res.status(500).json({ error: 'Database error.' });
      }
      return res.status(200).json({ message: 'Patient updated successfully.', data: results });
  });
});
// DELETE /api/patients/delete/:id
app.delete('/api/patients/delete/:id', (req, res) => {
  const pat_id = req.params.id;

  const query = `CALL ManagePatientProfile(?, ?, NULL, NULL, NULL, NULL, NULL, NULL, NULL)`;

  db.query(query, ['DEL', pat_id], (err, results) => {
      if (err) {
          if (err.sqlState === '45000') {
              return res.status(400).json({ error: err.message });  // Custom error from the procedure
          }
          return res.status(500).json({ error: 'Database error.' });
      }
      return res.status(200).json({ message: 'Patient deleted (locked) successfully.', data: results });
  });
});


// Patient Login API
app.post('/api/login/patient', (req, res) => {
  const { phoneNo, dob } = req.body;

  // Call the stored procedure to log in the patient
  const callProcedure = `
      CALL LoginUser(?, ?, @patient_id, @message);
  `;

  // Execute the procedure
  db.query(callProcedure, [phoneNo, dob], (err) => {
      if (err) {
          console.error("Error executing procedure:", err);
          return res.status(500).json({ error: 'Error executing procedure' });
      }

      // Retrieve the output parameters
      const outputQuery = `
          SELECT @patient_id AS patient_id, @message AS message;
      `;

      db.query(outputQuery, (err, results) => {
          if (err) {
              console.error("Error retrieving output parameters:", err);
              return res.status(500).json({ error: 'Error retrieving output parameters' });
          }

          // Check if results exist and retrieve output values
          if (results.length > 0) {
              const { patient_id, message } = results[0];
              
              // Check if login was successful
              if (patient_id) {
                  return res.status(200).json({ message: 'Login successful', patient_id });
              } else {
                  // Login failed
                  return res.status(401).json({ message }); // Return the error message from the procedure
              }
          } else {
              // No results found
              return res.status(404).json({ message: 'No results found' });
          }
      });
  });
});

// Patient Details API
app.get('/api/Retrievepatient/:id', (req, res) => {
  const patientId = req.params.id;

  // Prepare the SQL query to call the stored procedure
  const sql = `
      CALL Retrieve_Pat_Details(?, @name, @dob, @address, @phone_no, @email, @registration_no, @sex,@status);
  `;

  // Execute the stored procedure
  db.query(sql, [patientId], (err) => {
      if (err) {
          console.error('Error executing stored procedure:', err);
          return res.status(500).json({ message: 'Error executing stored procedure' });
      }

      // Query to retrieve the output values from the stored procedure
      const outputSql = `
          SELECT @name AS name, @dob AS dob, @address AS address, 
                 @phone_no AS phone_no, @email AS email, 
                 @registration_no AS regno, @sex AS sex,@status AS status;
      `;

      // Fetch output values
      db.query(outputSql, (err, results) => {
          if (err) {
              console.error('Error retrieving output values:', err);
              return res.status(500).json({ message: 'Error retrieving patient details' });
          }

          if (results.length > 0) {
              return res.status(200).json(results[0]); // Return patient details
          } else {
              return res.status(404).json({ message: 'Patient not found' });
          }
      });
  });
});


app.get('/api/specialties', (req, res) => {
  db.query('CALL GetAllSpecialties()', (error, results) => {
    if (error) {
      console.error('Error fetching specialties: ', error);
      return res.status(500).json({ error: 'Database query failed' });
    }

    // results is an array, with the first element being the result set
    const specialties = results[0].map(row => row.stf_speciality);
    res.json(specialties);
  });
});

app.get('/api/doctors/:specialty', (req, res) => {
  const specialtyName = req.params.specialty; // Get the specialty from the URL parameters

  db.query('CALL GetDoctorsBySpecialty(?)', [specialtyName], (error, results) => {
    if (error) {
      console.error('Error fetching doctors: ', error);
      return res.status(500).json({ error: 'Database query failed' });
    }

    // results is an array, with the first element being the result set
    const doctors = results[0].map(row => ({
      id: row.stf_id,    // Assuming stf_id is the doctor's ID
      name: row.stf_name  // Assuming stf_name is the doctor's name
    }));

    res.json(doctors); // Respond with the list of doctors
  });
});

app.get('/api/available-dates/:doctorId', (req, res) => {
  const doctorId = req.params.doctorId;

  // Log the incoming request
  console.log('Fetching available dates for doctor ID:', doctorId);

  // Execute the stored procedure
  db.query('CALL GetNextSevenAvailableDates(?);', [doctorId], (error, results) => {
      if (error) {
          console.error('Error executing query:', error);
          return res.status(500).json({ error: 'Internal Server Error' });
      }

      // Access the results
      const availableDates = results[0]; // The first result set contains the available dates

      if (availableDates.length > 0) {
          res.json({ available_dates: availableDates });
      } else {
          res.json({ message: 'No available dates found.' });
      }
  });
});



app.get('/api/available-slots/:doctorId/:date', (req, res) => {
  const doctorId = parseInt(req.params.doctorId); // Get doctor ID from URL parameters
  const selectedDate = req.params.date; // Get selected date from URL parameters

  db.query('CALL ShowAvailableSlots(?, ?)', [doctorId, selectedDate], (error, results) => {
    if (error) {
      console.error('Error fetching available slots: ', error);
      return res.status(500).json({ error: 'Database query failed' });
    }

    // results is an array, with the first element being the result set
    const slots = results[0].map(row => ({
      id: row.tok_id,               // Token ID
      fromTime: row.tok_fr_time,    // Start time of the slot
      toTime: row.tok_to_time,      // End time of the slot
      tokenNumber: row.tok_no,       // Token number
      status: row.tok_status         // Token status
    }));

    res.json(slots); // Respond with the list of available slots
  });
});

app.post('/api/book-appointment', (req, res) => {
  const { doctorId, patientId, appointmentDate, timeSlot, tokenNumber } = req.body;

  // Log the incoming request
  console.log('Booking appointment for Doctor ID:', doctorId, 'Patient ID:', patientId);

  // Ensure required parameters are provided
  if (!doctorId || !patientId || !appointmentDate || !timeSlot || !tokenNumber) {
      return res.status(400).json({ error: 'All parameters are required' });
  }

  // Execute the stored procedure to book the appointment
  db.query('CALL BookAppointment(?, ?, ?, ?, ?);', 
      [doctorId, patientId, appointmentDate, timeSlot, tokenNumber], 
      (error, results) => {
          if (error) {
              console.error('Error executing query:', error);
              return res.status(500).json({ error: 'Internal Server Error' });
          }

          // If booking is successful, send a success response
          res.json({ message: 'Appointment booked successfully!' });
      }
  );
});

app.get('/api/appointments/:patientId', (req, res) => {
    const patientId = parseInt(req.params.patientId); // Get patient ID from URL parameters
    const flag = parseInt(req.query.flag); // Get flag from the query string

    // Check for valid flags: 1, 2, or 3
    if (isNaN(flag) || (flag < 1 || flag > 3)) {
        return res.status(400).json({ error: 'Invalid flag. Flag must be 1, 2, or 3.' });
    }

    // Call the stored procedure with the flag
    db.query('CALL GetAppointmentsByPatientId(?, ?)', [patientId, flag], (error, results) => {
        if (error) {
            console.error('Error fetching appointments:', error);
            return res.status(500).json({ error: 'Database query failed', message: error.message });
        }

        // Results is an array, with the first element being the result set
        const appointments = results[0].map(row => ({
            appointmentId: row.appointment_id,    // Appointment ID
            appointmentDate: row.appointment_date, // Appointment date
            timeSlot: row.time_slot,               // Time slot for the appointment
            doctorName: row.doctor_name,           // Name of the doctor
            tokenNumber: row.token_number,         // Token number
            remarks: row.remarks,                  // Remarks associated with the appointment
            status: row.status,                    // Status of the appointment
        }));

        res.json(appointments); // Respond with the list of appointments
    });
});



app.put('/api/appointments/update/:id', (req, res) => {
    const appointmentId = req.params.id; // Get the appointment ID from the URL parameters
    const { doctorId, patientId, appointmentDate, timeSlot, tokenNumber } = req.body; // Extract details from request body

    // Log the parameters
    console.log('Updating appointment with parameters:', {
        appointmentId,
        doctorId,
        patientId,
        appointmentDate,
        timeSlot,
        tokenNumber
    });

    // SQL query to call the stored procedure
    const query = `CALL UpdateAppointment(?, ?, ?, ?, ?, ?)`;

    // Execute the stored procedure with the provided parameters
    db.query(query, [appointmentId, doctorId, patientId, appointmentDate, timeSlot, tokenNumber], (err, results) => {
        if (err) {
            console.error('Error executing query:', err); // Log the error for debugging
            if (err.sqlState === '45000') {
                return res.status(400).json({ error: err.message }); // Return a 400 status for custom errors
            }
            return res.status(500).json({ error: 'Database error.' }); // Return a 500 status for general errors
        }
        return res.status(200).json({ message: 'Appointment updated successfully.', data: results }); // Success response
    });
});


// DELETE /api/appointments/cancel/:id
app.delete('/api/appointments/cancel/:appointmentId', (req, res) => {
    const appointmentId = parseInt(req.params.appointmentId);
    db.query('CALL CancelAppointment(?)', [appointmentId], (error, results) => {
        if (error) {
            console.error('Error cancelling appointment:', error);
            return res.status(500).json({ error: 'Database query failed', message: error.message });
        }
        res.json({ message: 'Appointment cancelled successfully' });
    });
});
  
app.post('/api/login/staff', async (req, res) => { // Add async here
    const { staffUsername, staffPassword } = req.body;

    db.getConnection((err, connection) => {
        if (err) {
            console.error('Error getting connection:', err);
            return res.status(500).json({ message: 'Error connecting to database' });
        }

        const callProcedure = "CALL LoginStaff(?)";
        connection.query(callProcedure, [staffUsername], async (err) => { // Make this query callback async
            if (err) {
                console.error('Error executing procedure:', err);
                connection.release();
                return res.status(500).json({ message: 'Error logging in staff', error: err.message });
            }

            const outputQuery = "SELECT @staff_id AS staff_id, @staff_type AS staff_type, @message AS message";
            connection.query(outputQuery, async (err, results) => { // Make this query callback async
                connection.release();
                if (err) {
                    console.error('Error retrieving output parameters:', err);
                    return res.status(500).json({ message: 'Error retrieving staff details', error: err.message });
                }

                const staffIdResult = results[0].staff_id;
                const staffTypeResult = results[0].staff_type;
                const message = results[0].message;

                if (message === 'Account is locked.') {
                    return res.status(401).json({ message });
                }

                if (message === 'Invalid credentials.') {
                    return res.status(401).json({ message });
                }

                // Compare the password and check for status
                connection.query("SELECT stf_pswd, stf_status FROM Staff WHERE stf_username = ?", [staffUsername], async (err, results) => { // Make this query callback async
                    if (err) {
                        console.error('Error fetching staff details:', err);
                        return res.status(500).json({ message: 'Error fetching staff details' });
                    }

                    if (results.length === 0 || results[0].stf_status === 'L') {
                        return res.status(401).json({ message: 'Account is locked or does not exist.' });
                    }

                    const { stf_pswd: storedPassword } = results[0];
                    const passwordMatch = await bcrypt.compare(staffPassword, storedPassword); // This can now use await

                    if (passwordMatch) {
                        // If login is successful, send staff ID and type
                        res.status(200).json({ message: 'Login successful.', staffId: staffIdResult, staffType: staffTypeResult });
                    } else {
                        res.status(401).json({ message: 'Invalid credentials.' });
                    }
                });
            });
        });
    });
});


// Endpoint to get doctor details
app.get('/api/doctor/:id', (req, res) => {
    const doctorId = req.params.id;
    db.query('CALL GetDoctorDetails(?)', [doctorId], (err, results) => {
        if (err) {
            return res.status(500).json({ message: 'Database error', error: err });
        }
        res.json(results[0][0]); // Return the first row from the result
    });
});

// Endpoint to update doctor password
app.post('/api/doctor/update-password', async (req, res) => {
    const { doctorId, newPassword } = req.body;

    // Hash the new password
    const hashedPassword = await bcrypt.hash(newPassword, 10);

    db.query('CALL UpdateDoctorPassword(?, ?)', [doctorId, hashedPassword], (err) => {
        if (err) {
            return res.status(500).json({ message: 'Database error', error: err });
        }
        res.json({ message: 'Password updated successfully' });
    });
});

// Get Admin Details
app.get('/api/admin/:id', (req, res) => {
    const adminId = req.params.id;
    db.query('CALL GetAdminDetails(?)', [adminId], (err, results) => {
        if (err) {
            return res.status(500).json({ message: 'Database error', error: err });
        }
        res.json(results[0][0]); // Return the first row from the result
    });
});

app.put('/api/admin/update/:id', async (req, res) => {
    const adminId = req.params.id;
    const {
      stf_name,
      stf_username,
      stf_sex,
      stf_speciality,
      stf_experience,
      stf_qualification,
      stf_email,
      stf_ph_no,
      stf_pswd, // Password to be updated
    } = req.body;
  
    // Initialize values array for the query
    const values = [
      stf_name,
      stf_username,
      stf_sex,
      stf_speciality,
      stf_experience,
      stf_qualification,
      stf_email,
      stf_ph_no,
    ];
  
    // Check if a new password is provided
    if (stf_pswd) {
      // Hash the new password
      const hashedPassword = await bcrypt.hash(stf_pswd, 10);
      values.push(hashedPassword); // Add the hashed password to the values array
    } else {
      // If no new password is provided, do not update the password field
      values.push(null); // Placeholder for password if not updating
    }
    values.push(adminId); // Add adminId at the end of values array
  
    // Update admin details, with condition to handle password
    const sql = `
      UPDATE Staff
      SET
        stf_name = ?,
        stf_username = ?,
        stf_sex = ?,
        stf_speciality = ?,
        stf_experience = ?,
        stf_qualification = ?,
        stf_email = ?,
        stf_ph_no = ?,
        stf_pswd = COALESCE(?, stf_pswd) -- Use COALESCE to keep existing password if not updating
      WHERE
        stf_id = ?`;
  
    db.query(sql, values, (err, result) => {
      if (err) {
        console.error('Error updating admin details:', err);
        return res.status(500).json({ message: 'Failed to update admin details' });
      }
      return res.status(200).json({ message: 'Admin details updated successfully' });
    });
  });




// API to get patients by doctor's ID
app.get('/api/patients/:staffId', (req, res) => {
    const staffId = req.params.staffId;
  
    db.query('CALL GetPatientsByDoctor(?)', [staffId], (err, results) => {
      if (err) {
        return res.status(500).json({ error: err.message });
      }
      res.json(results[0]); // Results of the procedure
    });
  });

 // Endpoint to get today's appointments for a doctor
app.get('/api/appointment/:staffId', (req, res) => {
  const staffId = req.params.staffId;

  db.query('CALL GetTodayAppointments(?)', [staffId], (error, results) => {
    if (error) {
      console.error("Error fetching appointments:", error);
      return res.status(500).json({ error: 'Error fetching appointments' });
    }
    res.json(results[0]); // results[0] contains the result set
  });
});


 
// Route for applying leave
app.post('/api/leave', (req, res) => {
    const { hol_stf_id, hol_type, hol_date, hol_reason, hol_status } = req.body;

    // Input validation
    if (!hol_stf_id || !hol_type || !hol_date || !hol_reason) {
        return res.status(400).json({ error: 'All fields are required.' });
    }

    // SQL query to insert a new leave request
    const sql = "INSERT INTO Holiday (hol_stf_id, hol_type, hol_date, hol_reason, hol_status) VALUES (?, ?, ?, ?, ?)";
    const values = [hol_stf_id, hol_type, hol_date, hol_reason, hol_status];

    db.query(sql, values, (error, results) => {
        if (error) {
            // Log the error to help identify the issue
            console.error("Database error:", error);
            return res.status(500).json({ error: 'An error occurred while processing your request.' });
        }
        res.status(201).json({ message: 'Leave applied successfully!', id: results.insertId });
    });
});


app.post('/api/updateLeaveStatus', (req, res) => {
  const { holId, hol_type, hol_date, hol_reason, hol_status } = req.body; // Ensure holId is extracted

  const query = 'UPDATE Holiday SET hol_type = ?, hol_date = ?, hol_reason = ?, hol_status = ? WHERE hol_id = ?';
  const values = [hol_type, hol_date, hol_reason, hol_status, holId]; // Include all values in the correct order

  db.query(query, values, (error, results) => {
    if (error) {
      console.error('Error updating leave status:', error);
      return res.status(500).json({ success: false, message: 'Database error' });
    }

    if (results.affectedRows === 0) {
      // Handle the case where no rows were updated
      return res.status(404).json({ success: false, message: 'Leave not found' });
    }

    return res.status(200).json({ success: true });
  });
});

  
  // Route for updating leave
app.put('/api/leave/:id', (req, res) => {
  const { id } = req.params; // Get the leave ID from the URL parameter
  const { hol_type, hol_date, hol_reason, hol_status } = req.body;


  const sql = 'UPDATE Holiday SET hol_type = ?, hol_date = ?, hol_reason = ?, hol_status = ? WHERE hol_id = ?';
  db.query(sql, [hol_type, hol_date, hol_reason, hol_status, id], (err, result) => {
    if (err) {
      console.error('Database error:', err);
      return res.status(500).send('Database error');
    }
    if (result.affectedRows === 0) {
      return res.status(404).send('Leave not found');
    }
    res.status(200).send('Leave updated successfully!');
  });
});

  
  // API to delete leave
  app.delete('/api/leave/:id', (req, res) => {
    const leaveId = req.params.id;

    // SQL query to delete the leave application
    const sql = "DELETE FROM Holiday WHERE hol_id = ?";
    db.query(sql, [leaveId], (error, results) => {
        if (error) {
            console.error("Database error:", error);
            return res.status(500).json({ error: 'An error occurred while processing your request.' });
        }
        if (results.affectedRows === 0) {
            return res.status(404).json({ error: 'Leave application not found.' });
        }
        res.status(204).send(); // No content
    });
});

  // API to get leave history
  app.get('/api/leave/:staff_id', (req, res) => {
    const { staff_id } = req.params;
    db.query('CALL GetLeaveHistory(?)', [staff_id], (error, results) => {
      if (error) {
        return res.status(500).json({ error: error.message });
      }
      res.status(200).json(results[0]); // results[0] contains the result set
    });
  });
  
// Get All Leaves with optional status filter
app.get('/api/leave', (req, res) => {
  const status = req.query.status; // Get the status from the query parameters
  let sql = 'CALL GetAllLeaves()'; // Default to getting all leaves

  // If a status is provided, modify the query
  if (status) {
    sql = 'CALL GetLeavesByStatus(?)'; // You should create this stored procedure to handle the filtering
  }

  db.query(sql, [status], (err, results) => {
      if (err) return res.status(500).send(err);
      res.json(results[0]);
  });
});


// Approve or Reject a Leave Application
app.put('/api/leaves/:id', (req, res) => {
  const { status } = req.body;
  const leaveId = req.params.id; // Get leave ID from URL

  db.query('CALL ApproveRejectLeave(?, ?)', [leaveId, status], (err) => {
      if (err) return res.status(500).send(err);
      res.send(`Leave application ${status === 'A' ? 'A' : 'R'}.`);
  });
});



app.get('/api/patient/:patientId/history', (req, res) => {
  const patientId = req.params.patientId;
  const query = 'CALL GetConsultationHistory(?)';

  connection.query(query, [patientId], (error, results) => {
      if (error) {
          return res.status(500).send('Error fetching history');
      }
      res.json(results[0]); // Return the consultation and medication history
  });
});


app.post('/api/addNewChart', async (req, res) => {
  const {
    patientRegNo,
    doctorId,
    appointmentDate,
    patientCondition,
    diagnosis,
    remarks,
    medicationEntries // expecting an array of medication entries
  } = req.body;

  console.log('Appointment Date:', appointmentDate);

  const query = `CALL AddNewChart(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;

  try {
    // Loop through the medication entries and call the stored procedure for each
    for (const med of medicationEntries) {
      const params = [
        patientRegNo,
        doctorId,
        appointmentDate,
        patientCondition,
        diagnosis,
        remarks,
        med.name,
        med.dosage,
        med.duration,
        med.instruction,
        med.remarks
      ];

      await new Promise((resolve, reject) => {
        db.query(query, params, (error, results) => {
          if (error) {
            console.error('Error executing query:', error);
            return reject(error);
          }
          resolve(results);
        });
      });
    }
    res.status(200).send('Charts successfully saved!');
  } catch (error) {
    console.error('Error saving data:', error);
    res.status(500).send('Internal Server Error');
  }
});

// Add this to your server.js or appropriate routes file
app.get('/api/patientHistory/:regNo', (req, res) => {
  const { regNo } = req.params;

  const query = `
    SELECT 
        c.cons_id, c.cons_pat_condition, c.cons_diagnosis, c.cons_remarks, 
        c.cons_appt_id, c.cons_stf_id,
        a.appt_date,  -- Appointment date
        s.stf_name,   -- Staff name
        m.med_name, m.med_dosage, m.med_duration, m.med_instruction, m.med_remarks
    FROM Consultation c
    LEFT JOIN Medication m ON c.cons_id = m.med_cons_id
    LEFT JOIN Appointment a ON c.cons_appt_id = a.appt_id  -- Join with the Appointment table
    LEFT JOIN Staff s ON c.cons_stf_id = s.stf_id  -- Join with the Staff table
    WHERE c.cons_pat_id = (SELECT pat_id FROM Patient WHERE pat_reg_no = ?)
      AND a.appt_status = 'F'  -- Only include full day appointments
  `;

  db.query(query, [regNo], (error, results) => {
      if (error) {
          console.error('Error fetching patient history:', error);
          return res.status(500).send('Internal Server Error');
      }
      res.json(results);
  });
});


app.get('/api/patientsId/:regNo', (req, res) => {
  const regNo = req.query.regNo;
  // Query the database to find the patient ID based on regNo
  // Example query
  connection.query('SELECT patientId FROM Patients WHERE regNo = ?', [regNo], (error, results) => {
      if (error) {
          return res.status(500).json({ error: 'Database query failed.' });
      }
      if (results.length > 0) {
          return res.json({ patientId: results[0].patientId });
      } else {
          return res.status(404).json({ error: 'Patient not found.' });
      }
  });
});


app.get('/api/appointments/count/:staffId', (req, res) => {
  const { staffId } = req.params; // Get staffId from URL parameters

  const currentDate = new Date().toISOString().slice(0, 10); // Format YYYY-MM-DD

  // SQL query to count total appointments and upcoming appointments for today for the specific staff
  const query = `
    SELECT 
      COUNT(*) AS totalAppointments, 
      SUM(CASE WHEN appt_status = 'B' THEN 1 ELSE 0 END) AS upcomingAppointments 
    FROM Appointment 
    WHERE appt_date = ? AND (appt_status = 'F' OR appt_status = 'B') AND appt_stf_id = ?`; // Ensure this is the correct column name for staff ID

  db.query(query, [currentDate, staffId], (err, results) => {
    if (err) {
      return res.status(500).json({ error: err.message });
    }
    
  });
});

// Start the server
app.listen(port, () => {
  console.log(`Server running on http://localhost:${port}`);
});



import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import axios from 'axios';

const DocAppmt = () => {
  const [appointmentsData, setAppointmentsData] = useState([]);
  const navigate = useNavigate();
  const staffId = localStorage.getItem('staff_id'); // Assuming staff ID is stored in localStorage

  useEffect(() => {
    const fetchAppointments = async () => {
      try {
        const response = await axios.get(`http://localhost:5000/api/appointment/${staffId}`);
        setAppointmentsData(response.data);

      } catch (error) {
        console.error("Error fetching appointments:", error);
      }
    };

    fetchAppointments();
  }, [staffId]);
  

  const addChart = (tokenNo, regNo) => {
    alert(`Adding chart for token number: ${tokenNo}`);
    goToNewPage(regNo); // Pass the regNo to the function
  };

  const goToNewPage = (regNo) => {
    localStorage.setItem('regno', regNo);

navigate('/doctorpage/appointment_schedule/chart'); // Navigate to the new page
  };

  return (
    <div className="min-h-screen bg-[#FFE8D6] p-6">
      <div className=" w-full bg-[#DDB892] shadow-md rounded-md p-6 ">
        <h1 className="text-2xl font-bold mb-10 text-center text-gray-700">Appointment Schedule List</h1>

        <table className="w-full bg-[#DDB892] border border-gray-300">
          <thead>
            <tr className="bg-[#E6CCB2] text-left">
              <th className="p-3 text-center">Token No</th>
              <th className="p-3 text-center">Reg No</th>
              <th className="p-3 text-center">Name</th>
              <th className="p-3 text-center">Age</th>
              <th className="p-3 text-center">Sex</th>
              <th className="p-3 text-center">Actions</th>
            </tr>
          </thead>
          <tbody>
            {appointmentsData?.map((appointment, index) => (

              <tr key={index} className="border-b">
                <td className="p-3 text-center">{appointment.tokenNo}</td>
                <td className="p-3 text-center">{appointment.regNo}</td>
                <td className="p-3 text-center">{appointment.name}</td>
                <td className="p-3 text-center">{appointment.age}</td>
                <td className="p-3 text-center">{appointment.sex}</td>
                <td className="p-3 text-center">
                  <button
                    onClick={() => addChart(appointment.tokenNo, appointment.regNo)}  // Pass regNo along with tokenNo
                    className="bg-[#7F4F24] hover:bg-[#7F5539] text-white font-bold py-2 px-4 rounded transition duration-300 transform hover:scale-105"
                  >
                    Add Chart
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};

export default DocAppmt;
